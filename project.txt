â”œâ”€ ./
â”‚   â”œâ”€ .env

â”‚   # --- Begin: .env ---
MONGO_URI = mongodb+srv://split_app:sushantno111@cluster0.akpgore.mongodb.net/
PORT = 5000
â”‚   # --- End: .env ---

â”‚   â”œâ”€ package.json

â”‚   # --- Begin: package.json ---
{
  "name": "split-app-backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "joi": "^17.13.3",
    "mongoose": "^8.16.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}

â”‚   # --- End: package.json ---

â”‚   â”œâ”€ project.txt

â”‚   # --- Begin: project.txt ---

â”‚   # --- End: project.txt ---

â”‚   â”œâ”€ README.md

â”‚   # --- Begin: README.md ---

# ðŸ’¸ Split Expense App - Backend

This is the backend system for a Split Expense App, designed to help groups of people split expenses fairly and track who owes whom. Inspired by Splitwise, the system supports expense tracking, settlement calculation, and data validation.

âœ… Built with **Node.js, Express, MongoDB, Joi**, and follows modular, RESTful architecture.

---

## ðŸ“ Project Structure

```
split-expense-backend/
â”œâ”€â”€ config/
â”‚   â””â”€â”€ db.js
â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ expenseController.js
â”‚   â””â”€â”€ settlementController.js
â”œâ”€â”€ middleware/
â”‚   â”œâ”€â”€ errorHandler.js
â”‚   â”œâ”€â”€ responseFormatter.js
â”‚   â””â”€â”€ validateRequest.js
â”œâ”€â”€ models/
â”‚   â””â”€â”€ Expense.js
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ expenses.js
â”‚   â””â”€â”€ settlements.js
â”œâ”€â”€ validators/
â”‚   â””â”€â”€ expenseSchema.js
â”œâ”€â”€ .env
â”œâ”€â”€ server.js
â”œâ”€â”€ package.json
â””â”€â”€ README.md
```

---

## ðŸš€ Features

### Core Functionalities

- Add, view, update, and delete expenses
- Split expenses equally, by percentage, or exact amounts
- Automatically calculate balances for all users
- Generate simplified settlements (minimize number of transactions)
- Derive all people from expense entries

### Validation & Error Handling

- Joi-based request validation
- Centralized response formatting middleware
- Proper HTTP status codes (400, 404, 500, etc.)
- Catch-all route for invalid endpoints

---

## ðŸ“¡ API Endpoints

### Expense Management

- `GET /expenses` - List all expenses
- `POST /expenses` - Add a new expense
- `PUT /expenses/:id` - Update an existing expense
- `DELETE /expenses/:id` - Delete an expense

### Settlement & Balances

- `GET /people` - List all involved people
- `GET /balances` - Get current balances per person
- `GET /settlements` - Generate simplified settlement summary

---

## ðŸ” Sample Payloads

### Add Expense

```json
POST /expenses
{
  "amount": 450,
  "description": "Groceries",
  "paid_by": "Sanket",
  "participants": ["Shantanu", "Om"],
  "split_type": "equal"
}
```

### Response Format

```json
{
  "success": true,
  "message": "Expense added successfully",
  "data": {
    "_id": "abc123",
    "amount": 450,
    "description": "Groceries",
    ...
  }
}
```

---

## ðŸ§ª Validation Rules

| Field         | Rule                                        |
|---------------|---------------------------------------------|
| `amount`      | Required, must be a positive number         |
| `description` | Required string                             |
| `paid_by`     | Required string                             |
| `participants`| Required array with at least 1 participant  |
| `split_type`  | Must be 'equal', 'percentage', or 'exact'   |
| `split_values`| Required if type is not 'equal'             |

---

## ðŸŒ Deployment Instructions

> You can deploy this backend using [Render](https://render.com), [Railway](https://railway.app), or any Node-compatible platform.

### 1. Clone the repo

```bash
git clone https://github.com/your-username/split-expense-backend.git
cd split-expense-backend
```

### 2. Install dependencies

```bash
npm install
```

### 3. Create `.env` file

```
MONGO_URI=<your-mongo-uri>
PORT=5000
```

### 4. Run the server

```bash
npm run dev
```

---

## ðŸ“¬ Postman Collection

> A public Postman collection with live demo data and endpoints is recommended.

- ðŸ”— [Postman Gist (Replace with actual link)](https://gist.github.com/your-postman-gist)
- Includes:
  - People: Shantanu, Sanket, Om
  - Expenses: Dinner, Groceries, Petrol, Pizza, Movie
  - Edge case tests and settlement scenarios

---

## ðŸ§­ Known Limitations

- Authentication is not implemented (no JWT)
- No recurring or automated expenses
- No UI or dashboard (backend only)

---

## âœ¨ Optional Features (Planned)

- [ ] Expense categories (Food, Travel, Utilities)
- [ ] Monthly analytics (spending charts, summaries)
- [ ] Recurring bills (rent, subscriptions)
- [ ] Frontend web UI or React dashboard

---

## ðŸ›  Tech Stack

- Backend: Node.js + Express
- Database: MongoDB Atlas
- Validation: Joi
- Testing: Postman
- Deployment: Render / Railway / Vercel (API)

---

## ðŸ‘¨â€ðŸ’» Author

Made with â¤ï¸ by **Sushant Gavaraskar**  
For **DevDynamics Backend Intern Assignment**

---

## ðŸ“„ License

This project is open-source under the [MIT License](LICENSE).

â”‚   # --- End: README.md ---

â”‚   â”œâ”€ server.js

â”‚   # --- Begin: server.js ---
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
require('dotenv').config();

// Custom modules
const connectDB = require('./config/db');
const expenseRoutes = require('./routes/expenses');
const settlementRoutes = require('./routes/settlements');
const analyticsRoutes = require('./routes/analytics');
const errorHandler = require('./middleware/errorHandler');

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// Connect to DB
connectDB();

// API Routes
app.use('/expenses', expenseRoutes);
app.use('/analytics', analyticsRoutes);
app.use('/', settlementRoutes); // Put last if it uses base path

// 404 Not Found Handler
app.use((req, res) => {
  res.status(404).json({ success: false, message: 'API endpoint not found' });
});

// Central Error Handler
app.use(errorHandler);

// Start server
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`âœ… Server running on port ${PORT}`));

â”‚   # --- End: server.js ---

â”‚   â”œâ”€ test.py

â”‚   # --- Begin: test.py ---
import os

def dump_project_to_txt(root_dir, output_file):
    """
    Dumps the full file structure and content of all files in the project,
    excluding only specific heavy/unnecessary folders and specific files.
    """
    # Folders to completely ignore (e.g., large or non-code)
    skip_dirs = {
        "node_modules", ".git", "__pycache__", "venv",
        ".idea", ".vscode", "dist", "build", ".mypy_cache"
    }

    # Specific filenames to ignore (e.g., lockfiles or OS files)
    skip_files = {
        "package-lock.json", "yarn.lock", ".DS_Store"
    }

    with open(output_file, "w", encoding="utf-8") as f:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Exclude unwanted directories during traversal
            dirnames[:] = [d for d in dirnames if d not in skip_dirs]

            level = dirpath.replace(root_dir, "").count(os.sep)
            indent = "â”‚   " * level
            f.write(f"{indent}â”œâ”€ {os.path.basename(dirpath)}/\n")

            sub_indent = "â”‚   " * (level + 1)
            for filename in filenames:
                if filename in skip_files:
                    continue

                full_path = os.path.join(dirpath, filename)
                f.write(f"{sub_indent}â”œâ”€ {filename}\n")

                try:
                    with open(full_path, "r", encoding="utf-8") as code_file:
                        code = code_file.read()
                        f.write(f"\n{sub_indent}# --- Begin: {filename} ---\n")
                        f.write(code + "\n")
                        f.write(f"{sub_indent}# --- End: {filename} ---\n\n")
                except Exception as e:
                    f.write(f"{sub_indent}[Could not read {filename}: {e}]\n")

# Example usage
dump_project_to_txt(".", "project.txt")

â”‚   # --- End: test.py ---

â”‚   â”œâ”€ config/
â”‚   â”‚   â”œâ”€ db.js

â”‚   â”‚   # --- Begin: db.js ---
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log("MongoDB Connected");
  } catch (err) {
    console.error("MongoDB Error:", err.message);
    process.exit(1);
  }
};

module.exports = connectDB;

â”‚   â”‚   # --- End: db.js ---

â”‚   â”œâ”€ controllers/
â”‚   â”‚   â”œâ”€ analyticsController.js

â”‚   â”‚   # --- Begin: analyticsController.js ---
const Expense = require('../models/Expense');
const { successResponse, errorResponse } = require('../middleware/responseFormatter');
const moment = require('moment');

exports.getMonthlySummary = async (req, res, next) => {
  try {
    const expenses = await Expense.find();
    const summary = {};

    expenses.forEach(exp => {
      const month = moment(exp.createdAt).format('YYYY-MM');
      if (!summary[month]) summary[month] = { total: 0, byPerson: {}, byCategory: {} };

      summary[month].total += exp.amount;

      if (!summary[month].byPerson[exp.paid_by]) summary[month].byPerson[exp.paid_by] = 0;
      summary[month].byPerson[exp.paid_by] += exp.amount;

      if (!summary[month].byCategory[exp.category]) summary[month].byCategory[exp.category] = 0;
      summary[month].byCategory[exp.category] += exp.amount;
    });

    return successResponse(res, summary, "Monthly summary generated");
  } catch (err) {
    next(err);
  }
};

exports.getCategorySummary = async (req, res, next) => {
  try {
    const expenses = await Expense.find();
    const summary = {};

    expenses.forEach(exp => {
      if (!summary[exp.category]) summary[exp.category] = 0;
      summary[exp.category] += exp.amount;
    });

    return successResponse(res, summary, "Category summary generated");
  } catch (err) {
    next(err);
  }
};

â”‚   â”‚   # --- End: analyticsController.js ---

â”‚   â”‚   â”œâ”€ expenseController.js

â”‚   â”‚   # --- Begin: expenseController.js ---
const Expense = require('../models/Expense');
const { successResponse, errorResponse } = require('../middleware/responseFormatter');

// Normalize helper
const normalize = (name) => name.trim().toLowerCase();

exports.addExpense = async (req, res, next) => {
  try {
    let {
      amount,
      description,
      paid_by,
      participants,
      split_type,
      split_values,
      category,
      
    } = req.body;

    paid_by = normalize(paid_by);
    participants = participants.map(normalize);

    const expense = new Expense({
      amount,
      description,
      paid_by,
      participants,
      split_type,
      split_values,
      category,
      
    });

    await expense.save();
    return successResponse(res, expense, "Expense added successfully", 201);
  } catch (error) {
    next(error);
  }
};

exports.getAllExpenses = async (req, res, next) => {
  try {
    const expenses = await Expense.find().sort({ createdAt: -1 });
    return successResponse(res, expenses, "Expenses retrieved successfully");
  } catch (error) {
    next(error);
  }
};

exports.updateExpense = async (req, res, next) => {
  try {
    const updateData = {};
    const fields = [
      "amount", "description", "split_type", "split_values",
      "category", "is_recurring", "recurrence"
    ];

    fields.forEach(field => {
      if (req.body[field] !== undefined) updateData[field] = req.body[field];
    });

    if (req.body.paid_by) {
      updateData.paid_by = normalize(req.body.paid_by);
    }

    if (req.body.participants) {
      updateData.participants = req.body.participants.map(normalize);
    }

    const expense = await Expense.findByIdAndUpdate(req.params.id, updateData, { new: true });

    if (!expense) {
      return errorResponse(res, "Expense not found", 404);
    }

    return successResponse(res, expense, "Expense updated successfully");
  } catch (error) {
    next(error);
  }
};

exports.deleteExpense = async (req, res, next) => {
  try {
    const expense = await Expense.findByIdAndDelete(req.params.id);
    if (!expense) return errorResponse(res, "Expense not found", 404);

    return successResponse(res, {}, "Expense deleted successfully");
  } catch (error) {
    next(error);
  }
};

â”‚   â”‚   # --- End: expenseController.js ---

â”‚   â”‚   â”œâ”€ settlementController.js

â”‚   â”‚   # --- Begin: settlementController.js ---
const Expense = require('../models/Expense');
const { successResponse, errorResponse } = require('../middleware/responseFormatter');

const normalize = (name) => name.trim().toLowerCase();

exports.getPeople = async (req, res, next) => {
  try {
    const expenses = await Expense.find();
    const peopleSet = new Set();

    expenses.forEach(exp => {
      peopleSet.add(normalize(exp.paid_by));
      exp.participants.forEach(p => peopleSet.add(normalize(p)));
    });

    return successResponse(res, Array.from(peopleSet), "People fetched successfully");
  } catch (error) {
    next(error);
  }
};

exports.getBalances = async (req, res, next) => {
  try {
    const expenses = await Expense.find();
    const balances = {};

    expenses.forEach(exp => {
      const total = exp.amount;
      const { paid_by, participants, split_type, split_values } = exp;

      const payer = normalize(paid_by);
      const part = participants.map(normalize);

      [payer, ...part].forEach(p => {
        if (!balances[p]) balances[p] = 0;
      });

      balances[payer] += total;

      if (split_type === 'equal') {
        const share = total / part.length;
        part.forEach(p => balances[p] -= share);
      } else if (split_type === 'percentage') {
        part.forEach((p, i) => balances[p] -= (split_values[i] / 100) * total);
      } else if (split_type === 'exact') {
        part.forEach((p, i) => balances[p] -= split_values[i]);
      }
    });

    return successResponse(res, balances, "Balances calculated");
  } catch (error) {
    next(error);
  }
};

exports.getSettlementSummary = async (req, res, next) => {
  try {
    const expenses = await Expense.find();
    const balances = {};

    expenses.forEach(exp => {
      const total = exp.amount;
      const { paid_by, participants, split_type, split_values } = exp;

      const payer = normalize(paid_by);
      const part = participants.map(normalize);

      [payer, ...part].forEach(p => {
        if (!balances[p]) balances[p] = 0;
      });

      balances[payer] += total;

      if (split_type === 'equal') {
        const share = total / part.length;
        part.forEach(p => balances[p] -= share);
      } else if (split_type === 'percentage') {
        part.forEach((p, i) => balances[p] -= (split_values[i] / 100) * total);
      } else if (split_type === 'exact') {
        part.forEach((p, i) => balances[p] -= split_values[i]);
      }
    });

    const debtors = [], creditors = [];

    Object.entries(balances).forEach(([person, bal]) => {
      if (bal < -0.01) debtors.push({ person, amount: -bal });
      else if (bal > 0.01) creditors.push({ person, amount: bal });
    });

    debtors.sort((a, b) => b.amount - a.amount);
    creditors.sort((a, b) => b.amount - a.amount);

    const settlements = [];

    while (debtors.length && creditors.length) {
      const debtor = debtors[0];
      const creditor = creditors[0];

      const settleAmount = Math.min(debtor.amount, creditor.amount);
      settlements.push({
        from: debtor.person,
        to: creditor.person,
        amount: parseFloat(settleAmount.toFixed(2))
      });

      debtor.amount -= settleAmount;
      creditor.amount -= settleAmount;

      if (debtor.amount < 0.01) debtors.shift();
      if (creditor.amount < 0.01) creditors.shift();
    }

    return successResponse(res, settlements, "Settlement summary generated");
  } catch (error) {
    next(error);
  }
};

â”‚   â”‚   # --- End: settlementController.js ---

â”‚   â”œâ”€ middleware/
â”‚   â”‚   â”œâ”€ errorHandler.js

â”‚   â”‚   # --- Begin: errorHandler.js ---
const errorHandler = (err, req, res, next) => {
    console.error("", err.stack);
    const status = err.statusCode || 500;
  
    res.status(status).json({
      success: false,
      message: err.message || 'Internal Server Error',
      error: process.env.NODE_ENV === 'development' ? err.stack : undefined,
    });
  };
  
  module.exports = errorHandler;
  
â”‚   â”‚   # --- End: errorHandler.js ---

â”‚   â”‚   â”œâ”€ responseFormatter.js

â”‚   â”‚   # --- Begin: responseFormatter.js ---
exports.successResponse = (res, data = {}, message = "Success", statusCode = 200) => {
    return res.status(statusCode).json({
      success: true,
      message,
      data,
    });
};
exports.errorResponse = (res, message = "Error", statusCode = 500, error = null) => {
    return res.status(statusCode).json({
      success: false,
      message,
      error: process.env.NODE_ENV === 'development' ? error : undefined,
    });
};
  
 
â”‚   â”‚   # --- End: responseFormatter.js ---

â”‚   â”‚   â”œâ”€ validateRequest.js

â”‚   â”‚   # --- Begin: validateRequest.js ---
const validateRequest = (schema) => (req, res, next) => {
    const { error } = schema.validate(req.body, { abortEarly: false });
    if (error) {
      return res.status(400).json({
        success: false,
        message: "Validation failed",
        errors: error.details.map((e) => e.message),
      });
    }
    next();
  };
  
  module.exports = validateRequest;
  
â”‚   â”‚   # --- End: validateRequest.js ---

â”‚   â”œâ”€ models/
â”‚   â”‚   â”œâ”€ Expense.js

â”‚   â”‚   # --- Begin: Expense.js ---
const mongoose = require('mongoose');

const expenseSchema = new mongoose.Schema({
  amount: {
    type: Number,
    required: true,
    min: [0, "Amount must be positive"]
  },
  description: {
    type: String,
    required: [true, "Description is required"]
  },
  paid_by: {
    type: String,
    required: [true, "Paid By is required"]
  },
  participants: {
    type: [String],
    required: [true, "At least one participant is required"]
  },
  split_type: {
    type: String,
    enum: ['equal', 'percentage', 'exact'],
    default: 'equal'
  },
  split_values: {
    type: [Number],
    default: []
  },
  category: {
    type: String,
    enum: ['Food', 'Travel', 'Utilities', 'Entertainment', 'Other'],
    default: 'Other'
  },
 
}, { timestamps: true });

module.exports = mongoose.model('Expense', expenseSchema);

â”‚   â”‚   # --- End: Expense.js ---

â”‚   â”œâ”€ routes/
â”‚   â”‚   â”œâ”€ analytics.js

â”‚   â”‚   # --- Begin: analytics.js ---
const express = require('express');
const router = express.Router();
const analyticsController = require('../controllers/analyticsController');

router.get('/monthly-summary', analyticsController.getMonthlySummary);
router.get('/category-summary', analyticsController.getCategorySummary);

module.exports = router;

â”‚   â”‚   # --- End: analytics.js ---

â”‚   â”‚   â”œâ”€ expenses.js

â”‚   â”‚   # --- Begin: expenses.js ---
const express = require('express');
const router = express.Router();
const expenseController = require('../controllers/expenseController');
const validateRequest = require('../middleware/validateRequest');
const expenseSchema = require('../validators/expenseSchema');

router.post('/', validateRequest(expenseSchema), expenseController.addExpense);
router.get('/', expenseController.getAllExpenses);
router.put('/:id', validateRequest(expenseSchema), expenseController.updateExpense);
router.delete('/:id', expenseController.deleteExpense);

module.exports = router;

â”‚   â”‚   # --- End: expenses.js ---

â”‚   â”‚   â”œâ”€ settlements.js

â”‚   â”‚   # --- Begin: settlements.js ---
const express = require('express');
const router = express.Router();
const settlementController = require('../controllers/settlementController');

router.get('/people', settlementController.getPeople);
router.get('/balances', settlementController.getBalances);
router.get('/settlements', settlementController.getSettlementSummary);

module.exports = router;

â”‚   â”‚   # --- End: settlements.js ---

â”‚   â”œâ”€ validators/
â”‚   â”‚   â”œâ”€ expenseSchema.js

â”‚   â”‚   # --- Begin: expenseSchema.js ---
const Joi = require('joi');

const expenseSchema = Joi.object({
  amount: Joi.number().positive().required(),
  description: Joi.string().required(),
  paid_by: Joi.string().required(),
  participants: Joi.array().items(Joi.string()).min(1).required(),
  split_type: Joi.string().valid('equal', 'percentage', 'exact').required(),
  split_values: Joi.when('split_type', {
    is: 'equal',
    then: Joi.any().optional(),
    otherwise: Joi.array().items(Joi.number()).required()
  }),
  category: Joi.string().valid('Food', 'Travel', 'Utilities', 'Entertainment', 'Other').optional(),
  is_recurring: Joi.boolean().optional(),
  recurrence: Joi.string().valid('daily', 'weekly', 'monthly').when('is_recurring', {
    is: true,
    then: Joi.required()
  })
});

module.exports = expenseSchema;

â”‚   â”‚   # --- End: expenseSchema.js ---

